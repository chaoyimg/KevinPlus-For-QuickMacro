/*
 * This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package kevin.module.modules.exploit

import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.Render3DEvent
import kevin.event.UpdateEvent
import kevin.main.KevinClient
import kevin.module.*
import kevin.module.modules.misc.Teams
import kevin.utils.*
import net.minecraft.block.Block
import net.minecraft.client.entity.EntityOtherPlayerMP
import net.minecraft.init.Blocks
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C07PacketPlayerDigging
import net.minecraft.network.play.client.C0APacketAnimation
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.BlockPos
import net.minecraft.util.Vec3
import org.lwjgl.input.Mouse
import org.lwjgl.opengl.GL11
import java.awt.Color
import java.lang.Thread.sleep

class TP : Module("TP","Allows you to teleport around.",category = ModuleCategory.EXPLOIT) {
    val mode = ListValue("Mode", arrayOf("Flag","AAC", "Buzz"),"Flag")
    private val keepTick = IntegerValue("FlagKeepTick",40,10,60)
    private val autoBlockFind = BooleanValue("AutoBlockFind",false)
    private val blockFindBlock = BlockValue("BlockFindBlock", 26)
    private val blockFindRange = IntegerValue("BlockFindRange",6,2,6)

    private val aacFlySpeedValue = FloatValue("Speed", 0.8f, 0.1f, 2f)
    private val aacPathFindMode = ListValue("AACPathFindMode", arrayOf("Direct","FindPath"),"Direct")
    private val showPath = BooleanValue("ShowPath", true)
    private val colorModeV = ListValue("ColorMode", arrayOf("Custom","Rainbow"),"Custom")
    private val colorR = IntegerValue("R",255,0,255)
    private val colorG = IntegerValue("G",255,0,255)
    private val colorB = IntegerValue("B",255,0,255)
    private val posList = ArrayList<Vec3>()
    private val aliveTicks = IntegerValue("AliveTicks",20,10,50)
    private val glLineWidthValue = FloatValue("LineWidth",2F,1F,4F)
    private val aliveTimer = MSTimer()
    private var fakePlayer: EntityOtherPlayerMP? = null
    private var flagTPState = 0
    private var playerPos = Vec3(.0,.0,.0)
    override val tag: String
        get() = mode.get()
    override fun onEnable() {
        when(mode.get()) {
            "Flag" -> {
                flagTPState = if (!mc.playerController.isSpectator){
                    ChatUtils.messageWithStart("§7[§cTP§7] §cJump In To Void!")
                    0
                }else 1
            }
            "AAC" -> {
                val thePlayer = mc.thePlayer ?: return
                playerPos = Vec3(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)
                val playerMP = EntityOtherPlayerMP(mc.theWorld!!, thePlayer.gameProfile)
                playerMP.rotationYawHead = thePlayer.rotationYawHead;
                playerMP.renderYawOffset = thePlayer.renderYawOffset;
                playerMP.rotationYawHead = thePlayer.rotationYawHead
                playerMP.copyLocationAndAnglesFrom(thePlayer)
                mc.theWorld!!.addEntityToWorld(-1000, playerMP)
                //thePlayer.noClip = true
                fakePlayer = playerMP
            }
            "Buzz" -> {
                flagTPState = 0
                if (!mc.thePlayer.onGround) {
                    ChatUtils.messageWithStart("§7[§cTP§7] §cYou need to stand on ground to teleport!")
                    state = false
                    return
                }
                playerPos = Vec3(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)
                ChatUtils.messageWithStart("§7[§cTP§7] §cStand on ground and press Middle mouse button to teleport!")
                ChatUtils.messageWithStart("§7[§cTP§7] §cDisable TP to cancel Teleport.")
            }
        }
    }
    override fun onDisable() {
        flagTPState = 0
        when(mode.get()) {
            "AAC" -> {
                val thePlayer = mc.thePlayer
                if (thePlayer == null || fakePlayer == null)
                    return
                //thePlayer.setPositionAndRotation(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord, thePlayer.rotationYaw, thePlayer.rotationPitch)
                mc.theWorld!!.removeEntityFromWorld(fakePlayer!!.entityId)
                fakePlayer = null
                thePlayer.motionX = 0.0
                thePlayer.motionY = 0.0
                thePlayer.motionZ = 0.0

                val savePath = showPath.get()

                //Do teleport
                val packetY = arrayOf(1.1,1.1,1.2,1.2,.8,.8,.4,.0,.0,1.1,1.1)
                repeat(11){
                    if (savePath)
                        posList.add(Vec3(playerPos.xCoord,playerPos.yCoord+packetY[it],playerPos.zCoord))
                    mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(playerPos.xCoord,playerPos.yCoord+packetY[it],playerPos.zCoord,true))
                }
                when(aacPathFindMode.get()){
                    "Direct" -> {
                        val packets = (mc.thePlayer.getDistance(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord).toInt() / 10) + 1
                        val xV = ((thePlayer.posX - playerPos.xCoord)) / packets.toDouble()
                        val yV = ((thePlayer.posY - playerPos.yCoord)) / packets.toDouble()
                        val zV = ((thePlayer.posZ - playerPos.zCoord)) / packets.toDouble()
                        repeat(packets){
                            if (savePath)
                                posList.add(Vec3(playerPos.xCoord+xV*(it+1),playerPos.yCoord+yV*(it+1),playerPos.zCoord+zV*(it+1)))
                            mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(playerPos.xCoord+xV*(it+1),playerPos.yCoord+yV*(it+1),playerPos.zCoord+zV*(it+1),true))
                        }
                    }
                    "FindPath" -> {
                        val path = PathUtils.findBlinkPath2(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord,thePlayer.posX,thePlayer.posY,thePlayer.posZ,thePlayer.getDistance(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord) % 10.0)
                        path.forEach {
                            if (savePath)
                                posList.add(it)
                            mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(it.xCoord,it.yCoord,it.zCoord,true))
                        }
                    }
                }
                if (savePath)
                    posList.add(Vec3(thePlayer.posX,thePlayer.posY-1,thePlayer.posZ))
                mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(thePlayer.posX,thePlayer.posY-1,thePlayer.posZ,true))
                if (savePath)
                    posList.add(Vec3(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord))
                mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(playerPos.xCoord,playerPos.yCoord,playerPos.zCoord,true))
                Thread({
                    sleep(50L)
                    repeat(2) {
                        mc.netHandler.addToSendQueue(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                thePlayer.posX,
                                thePlayer.posY,
                                thePlayer.posZ,
                                true
                            )
                        )
                    }
                    sleep(50L)
                    mc.netHandler.addToSendQueue(
                        C03PacketPlayer.C04PacketPlayerPosition(
                            thePlayer.posX + .09,
                            thePlayer.posY,
                            thePlayer.posZ,
                            true
                        )
                    )
                },"Teleport-SendPacket").start()
                aliveTimer.reset()
            }
            "Buzz" -> {
                val thePlayer = mc.thePlayer ?: return
                thePlayer.motionX = 0.0
                thePlayer.motionY = 0.0
                thePlayer.motionZ = 0.0
                mc.thePlayer.setPosition(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord)
                if (flagTPState == 0) {
                    ChatUtils.messageWithStart("§7[§cTP§7] §cTeleport cancelled.")
                }
            }
        }
    }
    @EventTarget fun onUpdate(event: UpdateEvent){
        when(mode.get()){
            "Flag" -> {
                if (flagTPState >= 2){
                    mc.thePlayer.setPosition(mc.thePlayer.posX,mc.thePlayer.posY+9.25,mc.thePlayer.posZ)
                    mc.thePlayer.motionY=1.0
                    if (flagTPState > keepTick.get()+2) this.toggle()
                    flagTPState += 1
                }
                if (flagTPState == 1 && !mc.playerController.isSpectator) flagTPState = 2
                if (flagTPState == 0 && mc.playerController.isSpectator) flagTPState = 1
                if (autoBlockFind.get() && mc.playerController.isSpectator) {
                    val teams = KevinClient.moduleManager.getModule(Teams::class.java)
                    val yRange = blockFindRange.get() downTo -blockFindRange.get() + 1
                    val xzRange = -blockFindRange.get()..blockFindRange.get()
                    var findBlockPos:BlockPos? = null
                     l@ for (x in xzRange) {
                         for (z in xzRange) {
                             for (y in yRange){
                                 val pos = BlockPos(mc.thePlayer.posX.toInt()+x, mc.thePlayer.posY.toInt()+y, mc.thePlayer.posZ.toInt()+z)
                                 if (BlockUtils.getBlock(pos) == Block.getBlockById(blockFindBlock.get()) && (BlockUtils.getBlock(pos) != Blocks.bed || (!teams.state||!teams.bedCheckValue.get()||pos !in teams.teamBed))) {
                                     findBlockPos = pos
                                     break@l
                                 }
                             }
                         }
                     }
                    if (findBlockPos!=null){
                        mc.thePlayer.setPositionAndUpdate(findBlockPos.x.toDouble()+.5,findBlockPos.y-1.toDouble(),findBlockPos.z.toDouble()+.5)
                        mc.thePlayer.motionX = .0
                        mc.thePlayer.motionY = .0
                        mc.thePlayer.motionZ = .0
                    }
                }
            }
            "AAC" -> {
                val thePlayer = mc.thePlayer!!
                //thePlayer.noClip = true
                thePlayer.fallDistance = 0.0f
                val value = aacFlySpeedValue.get()
                thePlayer.motionY = 0.0
                thePlayer.motionX = 0.0
                thePlayer.motionZ = 0.0
                if (mc.gameSettings.keyBindJump.isKeyDown) thePlayer.motionY += value
                if (mc.gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY -= value
                MovementUtils.strafe(value)
            }
            "Buzz" -> {
                val thePlayer = mc.thePlayer ?: return
                thePlayer.fallDistance = 0f
                val fixedY = mc.thePlayer.posY - (mc.thePlayer.posY % 1)
                thePlayer.motionY = 0.0
                thePlayer.motionX = 0.0
                thePlayer.motionZ = 0.0
                when (flagTPState) {
                    0 -> {
                        val value = aacFlySpeedValue.get()
                        if (mc.gameSettings.keyBindJump.isKeyDown) thePlayer.motionY += value / 2f
                        if (mc.gameSettings.keyBindSneak.isKeyDown) thePlayer.motionY -= value / 2f
                        MovementUtils.strafe(value)
                        if (MovementUtils.isMoving || mc.gameSettings.keyBindJump.isKeyDown || mc.gameSettings.keyBindSneak.isKeyDown) {
                            val locVec = Vec3(thePlayer.posX, thePlayer.posY, thePlayer.posZ)
                            posList.add(locVec)
                        }
                        if (Mouse.isButtonDown(2)) {
                            if ((BlockUtils.getBlock(BlockPos(mc.thePlayer.posX, fixedY - 1, mc.thePlayer.posZ)) ?: return).isFullBlock) {
                                flagTPState = 1
                                ChatUtils.messageWithStart("§7[§cTP§7] §cTeleporting...")
                                mc.thePlayer.setPosition(mc.thePlayer.posX, fixedY, mc.thePlayer.posZ)
                                PacketUtils.sendPacketNoEvent(
                                    C04PacketPlayerPosition(
                                        playerPos.xCoord,
                                        playerPos.yCoord - (0.08 * 0.98f),
                                        playerPos.zCoord,
                                        false
                                    )
                                )
                            } else {
                                ChatUtils.messageWithStart("§7[§cTP§7] §cYou can only land on a solid block!")
                            }
                        }
                    }
                    1 -> {
                        mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ)
                    }
                    2 -> {
                        val curPos = Vec3(thePlayer.posX, fixedY, thePlayer.posZ)
                        synchronized(posList) {
                            for (vec3 in posList) {
                                PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(vec3.xCoord, vec3.yCoord, vec3.zCoord, false))
                            }
                            posList.clear()
                        }
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(curPos.xCoord, curPos.yCoord, curPos.zCoord, thePlayer.rotationYaw, thePlayer.rotationPitch, true))
                        playerPos = curPos
                        mc.thePlayer.setPosition(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord)
                        flagTPState = 3
                    }
                    3, 4 -> {
                        if (thePlayer.ticksExisted % 2 == 0) PacketUtils.sendPacketNoEvent(C04PacketPlayerPosition(playerPos.xCoord, playerPos.yCoord - (0.08 * 0.98f), playerPos.zCoord, false))
                        else PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord, thePlayer.rotationYaw, thePlayer.rotationPitch, true))
                        mc.thePlayer.setPosition(playerPos.xCoord, playerPos.yCoord, playerPos.zCoord)
                    }
                }
            }
        }
    }
    @EventTarget fun onPacket(event: PacketEvent) {
        val packet = event.packet
        when(mode.get()){
            "AAC" -> {
                if (packet is C03PacketPlayer || packet is C0BPacketEntityAction || packet is C07PacketPlayerDigging || packet is C0APacketAnimation) event.cancelEvent()
            }
            "Buzz" -> {
                if (packet is C03PacketPlayer) {
                    event.cancelEvent()
                    if (flagTPState == 0 && mc.thePlayer.ticksExisted % 10 != 0) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                } else if (packet is C0BPacketEntityAction || packet is C07PacketPlayerDigging || packet is C0APacketAnimation) event.cancelEvent()
                else if (packet is S08PacketPlayerPosLook) {
                    val tpVec = Vec3(packet.x, packet.y, packet.z)
                    if (tpVec.squareDistanceTo(playerPos) < 100) {
                        if (flagTPState == 1) {
                            PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.yaw, packet.pitch, false))
                            playerPos = tpVec
                            flagTPState = 2
                            event.cancelEvent()
                        } else if (flagTPState >= 3) {
                            state = false
                        }
                    } else {
                        if (flagTPState == 3) {
                            flagTPState = 4
                        } else if (flagTPState == 4) {
                            state = false
                            ChatUtils.messageWithStart("§7[§cTP§7] §cIt seem failed, auto disabled!")
                        }
                    }
                }
            }
        }
    }
    @EventTarget(true) fun onRender3D(event: Render3DEvent) {
        if (showPath.get() && posList.isNotEmpty()) {
            if (aliveTimer.hasTimePassed(50L*aliveTicks.get())) {
                posList.clear()
                return
            }
            synchronized(posList) {
                val renderPosX = mc.renderManager.viewerPosX
                val renderPosY = mc.renderManager.viewerPosY
                val renderPosZ = mc.renderManager.viewerPosZ

                GL11.glPushMatrix()
                GL11.glEnable(GL11.GL_BLEND)
                GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA)
                GL11.glShadeModel(GL11.GL_SMOOTH)
                GL11.glDisable(GL11.GL_TEXTURE_2D)
                GL11.glEnable(GL11.GL_LINE_SMOOTH)
                GL11.glDisable(GL11.GL_DEPTH_TEST)
                GL11.glDisable(GL11.GL_LIGHTING)
                GL11.glDepthMask(false)
                GL11.glHint(GL11.GL_LINE_SMOOTH_HINT, GL11.GL_NICEST)

                val colorD = if (colorModeV.get() == "Custom") Color(colorR.get(),colorG.get(),colorB.get()) else ColorUtils.rainbow()

                for (vec in posList){
                    val x = vec.xCoord - renderPosX
                    val y = vec.yCoord - renderPosY
                    val z = vec.zCoord - renderPosZ
                    val width = 0.3
                    val height = mc.thePlayer!!.eyeHeight.toDouble()
                    GL11.glLoadIdentity()
                    mc.entityRenderer.setupCameraTransform(mc.timer.renderPartialTicks, 2)
                    RenderUtils.glColor(colorD)
                    GL11.glLineWidth(glLineWidthValue.get())
                    GL11.glBegin(GL11.GL_LINE_STRIP)
                    GL11.glVertex3d(x - width, y, z - width)
                    GL11.glVertex3d(x - width, y, z - width)
                    GL11.glVertex3d(x - width, y + height, z - width)
                    GL11.glVertex3d(x + width, y + height, z - width)
                    GL11.glVertex3d(x + width, y, z - width)
                    GL11.glVertex3d(x - width, y, z - width)
                    GL11.glVertex3d(x - width, y, z + width)
                    GL11.glEnd()
                    GL11.glBegin(GL11.GL_LINE_STRIP)
                    GL11.glVertex3d(x + width, y, z + width)
                    GL11.glVertex3d(x + width, y + height, z + width)
                    GL11.glVertex3d(x - width, y + height, z + width)
                    GL11.glVertex3d(x - width, y, z + width)
                    GL11.glVertex3d(x + width, y, z + width)
                    GL11.glVertex3d(x + width, y, z - width)
                    GL11.glEnd()
                    GL11.glBegin(GL11.GL_LINE_STRIP)
                    GL11.glVertex3d(x + width, y + height, z + width)
                    GL11.glVertex3d(x + width, y + height, z - width)
                    GL11.glEnd()
                    GL11.glBegin(GL11.GL_LINE_STRIP)
                    GL11.glVertex3d(x - width, y + height, z + width)
                    GL11.glVertex3d(x - width, y + height, z - width)
                    GL11.glEnd()
                }
                GL11.glDepthMask(true)
                GL11.glEnable(GL11.GL_DEPTH_TEST)
                GL11.glDisable(GL11.GL_LINE_SMOOTH)
                GL11.glEnable(GL11.GL_TEXTURE_2D)
                GL11.glDisable(GL11.GL_BLEND)
                GL11.glPopMatrix()
                GL11.glColor4f(1F, 1F, 1F, 1F)
            }
        }
    }
}