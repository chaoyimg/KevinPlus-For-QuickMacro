/*
 * This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package kevin.module.modules.exploit

import io.netty.buffer.Unpooled
import kevin.event.*
import kevin.main.KevinClient
import kevin.module.*
import kevin.utils.ChatUtils
import kevin.utils.MSTimer
import kevin.utils.PacketUtils
import kevin.utils.RandomUtils
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import kotlin.math.floor
import kotlin.math.pow
import kotlin.math.roundToInt
import kotlin.math.sqrt

@Suppress("UNCHECKED_CAST", "UNUSED_PARAMETER")
object Disabler : Module("Disabler","Disable some anti-cheat check.",category = ModuleCategory.EXPLOIT) {
    // Basic settings
    val modeValue = ListValue("Mode",arrayOf("MineplexCombat","OldHypixel","BlocksMC","VerusCombat","VerusMove","VerusRidingSpoof","Flying","Spectate","SpectateSpoof","SpectateSpoof2","VulcanGeyser","C13+InfiniteC0C","NoGroundTouch","NoGroundTouch2","MemetrixScaffold","FakeLag","PingSpoof","RidingSpoof","OldKauri","MMCStrafe","Basic","MineLand","LessFlag", "None"),"MinePlexCombat")
    private val debug = BooleanValue("Debug", false)
    private val memeAACValue = BooleanValue("MemetrixWithAAC5", false)
    private val fakeLagPosValue = BooleanValue("FakeLagPosition", true)
    private val fakeLagBlockValue = BooleanValue("FakeLagBlock", true)
    private val fakeLagAttackValue = BooleanValue("FakeLagAttack", true)
    private val fakeLagSpoofValue = BooleanValue("FakeLagC03Spoof", false)
    private val lagDelayValue = IntegerValue("LagDelay",0,0,2000)
    private val lagDurationValue = IntegerValue("LagDuration",200,100,1000)
    private val pingSpoofMinDelay : IntegerValue = object : IntegerValue("PingSpoofMinDelay", 75, 0, 1000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            if (newValue > pingSpoofMaxDelay.get()) set(pingSpoofMaxDelay.get())
        }
    }
    private val pingSpoofMaxDelay : IntegerValue = object : IntegerValue("PingSpoofMaxDelay", 500, 0, 2000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            if (newValue < pingSpoofMinDelay.get()) set(pingSpoofMinDelay.get())
        }
    }
    private val pingSpoofLostC03Mode = ListValue("PingSpoofLostC03Mode", arrayOf("NoMove", "OnlyRotation"), "NoMove")
    private val pingSpoofLostC03Rate = FloatValue("PingSpoofLostC03Rate", 0.0f, 0.0f, 1.0f)
    // Custom Settings
    private val lolValue = TextValue("The values following is free at all, enable and setting which you need!", "")
    // Vulcan Strafe disabler
    // From FDP Client, coded by Co Dynamic in 2023/02/23
    // Source at: https://github.com/SkidderMC/FDPClient/blob/main/src/main/java/net/ccbluex/liquidbounce/features/module/modules/exploit/disablers/other/VulcanStrafeDisabler.kt
    private val vulcanStrafeDisabler : BooleanValue = object : BooleanValue("VulcanStrafeDisabler", false) {
        override fun onChanged(oldValue: Boolean, newValue: Boolean) {
            if (newValue) {
                vulcanStrafeDisabler2.set(false)
            }
        }
    }
    private val vulcanStrafeDelay = IntegerValue("VulcanStrafe-Delay", 6, 3, 10)
    private val vulcanStrafeDisabler2: BooleanValue = object : BooleanValue("VulcanStrafeDisabler2", false) {
        override fun onChanged(oldValue: Boolean, newValue: Boolean) {
            if (newValue) {
                vulcanStrafeDisabler.set(false)
            }
        }
    }
    // Also From FDP xD
    private val vulcanOmniSprintDisabler = BooleanValue("VulcanOmniSprintDisabler", false)
    // AutoBlock disabler
    // Vulcan's AutoBlock check based on C08 and C09, so you know what I will do
    private val vulcanAutoBlockDisabler = BooleanValue("VulcanAutoBlockDisabler", false)

    private var verus2Stat=false
    private var packetBuffer=mutableListOf<Packet<INetHandlerPlayServer>>()
    private var currentTrans=0
    private var memeTick=0
    private var nextRandomInt = 0L
    private var vulcanStrafeC03Counter = -15
    private var vulcanABHasAction = false
    private var isSent=false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()

    override fun onEnable() {
        reset()
    }

    override fun onDisable() {
        when(modeValue.get().lowercase()){
            "memetrixscaffold" -> {
                for(packet in packetBuffer){
                    resendPacket(packet)
                }
                packetBuffer.clear()
            }
            "fakelag" -> {
                for(packet in packetBuffer){
                    resendPacket(packet)
                }
                packetBuffer.clear()
            }
            "blocksmc" -> {
                for(packet in packetBuffer){
                    resendPacket(packet)
                }
                packetBuffer.clear()
            }
            "pingspoof" -> {
                for(packet in packetBuffer){
                    resendPacket(packet)
                }
                packetBuffer.clear()
            }
        }
    }

    @EventTarget
    fun onWorld(event: WorldEvent){
        reset()
    }

    private fun reset(){
        memeTick=0
        currentTrans=0
        verus2Stat=false
        vulcanStrafeC03Counter = -15
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent){
        when(modeValue.get().lowercase()){
            "verusmove" -> {
                // Partially drain the queue every 180 ticks (9 seconds), to prevent flagging Ping Spoof.
                if (mc.thePlayer.ticksExisted % 180 == 0) {
                    // grab packets until the queue size is 22 or less.
                    while (packetBuffer.size > 22) {
                        // grab 1 packet, send and then remove it from the queue
                        resendPacket(packetBuffer[0])
                        packetBuffer.removeAt(0)
                    }
                }
            }
            "memetrixscaffold" -> {
                memeTick++
                val cTick=if(memeAACValue.get()){
                    (mc.timer.timerSpeed.toDouble().pow(2.0)*10).roundToInt()
                }else{
                    (mc.timer.timerSpeed.toDouble().pow(2.0)*7.6).roundToInt()
                }
                if(memeTick>=cTick){
                    memeTick=0
                    for(packet in packetBuffer){
                        resendPacket(packet)
                    }

                    debugMessage("Release buf(size=${packetBuffer.size}, cTick=$cTick)")
                    packetBuffer.clear()
                }
            }
            "blocksmc" -> {
                if(isSent && fakeLagDelay.hasTimePassed(RandomUtils.nextInt(25, 450).toLong())) {
                    for(packet in packetBuffer){
                        resendPacket(packet)
                    }
                    packetBuffer.clear()
                    isSent = false

                    debugMessage("Release buf(size=${packetBuffer.size})")
                }
            }

            "fakelag" -> {
                if(!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
                //Send
                if(fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                    fakeLagDelay.reset()
                    fakeLagDuration.reset()
                    for(packet in packetBuffer){
                        resendPacket(packet)
                    }
                    debugMessage("Release buf(size=${packetBuffer.size})")
                    isSent=true
                    packetBuffer.clear()
                }
            }

            "pingspoof" -> {
                if (fakeLagDelay.hasTimePassed(nextRandomInt)) {
                    fakeLagDelay.reset()
                    nextRandomInt = RandomUtils.nextInt(pingSpoofMinDelay.get(), pingSpoofMaxDelay.get()).toLong()
                    while (packetBuffer.isNotEmpty()) {
                        resendPacket(packetBuffer.removeFirst())
                    }
                }
            }
        }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        if (event.eventState == EventState.PRE) {
            if (vulcanOmniSprintDisabler.get()) {
                mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SPRINTING))
                mc.netHandler.addToSendQueue(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SPRINTING))
            }
            if (vulcanStrafeDisabler2.get() && mc.thePlayer!!.ticksExisted % 5 == 0) {
                mc.netHandler.addToSendQueue(C07PacketPlayerDigging(C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK, BlockPos(-1,-1,-1), EnumFacing.UP))
            }
            if (modeValue equal "MineLand") {
                if (mc.thePlayer.ticksExisted in 21..40 && mc.thePlayer.onGround) {
                    isSent = true
                } else if (mc.thePlayer.ticksExisted == 100) {
                    isSent = false
                }

                if (this.isSent) {
                    event.onGround = true
                    event.posX = (mc.thePlayer.posX - 0.1 * if (mc.thePlayer.ticksExisted % 2 == 0) 1 else -1)
                    event.posZ = (mc.thePlayer.posZ - 0.1 * if (mc.thePlayer.ticksExisted % 2 == 0) 1 else -1)
                    event.posY = floor((mc.thePlayer.posY + 1) * 2.0) / 2.0
                }
            }
        }
    }

    @EventTarget
    fun onMovementInput(event: MovementInputUpdateEvent) {
        if (modeValue equal "MineLand" && isSent) {
            event.forward = 0f
            event.strafe = 0f
            event.jump = false
        }
    }


//    @EventTarget
// for safety, we modified met.minecraft.network.NetworkManager
    fun onPacket(event: PacketEvent){
        val packet = event.packet

        if (vulcanAutoBlockDisabler.get()) {
            if (packet is C08PacketPlayerBlockPlacement) {
                if (packet.placedBlockDirection == 255) {
                    if (vulcanABHasAction) {
                        event.cancelEvent()
                    }
                    vulcanABHasAction = true
                }
            } else if (packet is C07PacketPlayerDigging) {
                if (packet.status == C07PacketPlayerDigging.Action.RELEASE_USE_ITEM) {
                    if (vulcanABHasAction) {
                        event.cancelEvent()
                    }
                    vulcanABHasAction = true
                }
            } else if (packet is C02PacketUseEntity || packet is C0APacketAnimation) {
                if (vulcanABHasAction) {
                    if (packet is C02PacketUseEntity) {
                        if (packet.action == C02PacketUseEntity.Action.ATTACK) event.cancelEvent()
                    } else event.cancelEvent()
                }
                if (packet is C02PacketUseEntity) vulcanABHasAction = true
            } else if (packet is C03PacketPlayer) {
                vulcanABHasAction = false
            }
        }

        when(modeValue.get().lowercase()){
            "mineplexcombat" -> {
                if (packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(C00PacketKeepAlive(packet.key- RandomUtils.nextInt(1000, 2147483647)))
                    debugMessage("Packet C00")
                }
            }

            "oldhypixel" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    event.cancelEvent()
                    debugMessage("Packet C0F")
                }
            }

            "blocksmc" -> {
                if (packet is S08PacketPlayerPosLook) {
                    memeTick = -1
                    debugMessage("Receive S08")
                } else if (packet is C03PacketPlayer.C06PacketPlayerPosLook && memeTick == -1) {
                    event.cancelEvent()
                    debugMessage("Reply C06 (cancelled)")
                    // I don't want to make a new timer do this work...
                    if (fakeLagDuration.hasTimePassed(50)) {
                        mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(packet.x, packet.y, packet.z, packet.onGround))
                        fakeLagDuration.reset()
                        debugMessage("Reply C04")
                    }
                    ++memeTick
                } else if(packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                }
                // isSent -> needLag
                if (isSent && !event.isCancelled) { // FakeLag for verus
                    if (packet is C00PacketKeepAlive||packet is C02PacketUseEntity||packet is C03PacketPlayer
                        ||packet is C07PacketPlayerDigging||packet is C08PacketPlayerBlockPlacement
                        ||packet is C0APacketAnimation||packet is C0FPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }

            "verusridingspoof" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if(currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    debugMessage("Packet C0F (Trans=$currentTrans)")
                } else if(packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    debugMessage("Packet C0B")
                }
                if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
            }

            "veruscombat" -> {
                if (packet is C0FPacketConfirmTransaction) {
                    if(currentTrans > 0) event.cancelEvent()
                    currentTrans++
                    debugMessage("Packet C0F (Trans=$currentTrans)")
                } else if(packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    debugMessage("Packet C0B")
                }
            }

            "verusmove" -> {
                if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0) packetBuffer.clear()
                if (packet is C03PacketPlayer) {
                    // Set position to a valid block height (so Spoof NoFall works)
                    val yPos = (mc.thePlayer.posY / 0.015625).roundToInt() * 0.015625
                    mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)
                    if (mc.thePlayer.ticksExisted % 45 == 0) {
                        // Clip into ground and silently accept the teleport from the server. (This fucks with teleport compensation LOL)
                        PacketUtils.sendPacketNoEvent(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                mc.thePlayer.posX,
                                mc.thePlayer.posY,
                                mc.thePlayer.posZ,
                                true
                            )
                        )
                        PacketUtils.sendPacketNoEvent(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                mc.thePlayer.posX,
                                mc.thePlayer.posY - 11.725,
                                mc.thePlayer.posZ,
                                false
                            )
                        )
                        PacketUtils.sendPacketNoEvent(
                            C03PacketPlayer.C04PacketPlayerPosition(
                                mc.thePlayer.posX,
                                mc.thePlayer.posY,
                                mc.thePlayer.posZ,
                                true
                            )
                        )
                    }
                } else if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    // Cancel the teleport, and silently accept it.
                    if (diff <= 8) {
                        event.cancelEvent()
                        // LATEST verus ALWAYS expects a c06 within 30 seconds of a teleport if packets have been sent from the client after the teleport.
                        PacketUtils.sendPacketNoEvent(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.getYaw(),
                                packet.getPitch(),
                                true
                            )
                        )
                    }
                } else if (packet is C0FPacketConfirmTransaction) {
                    for (i in 0..3) {
                        // Make sure to dupe packets 4 times, since it will match up with the missing packets while keeping the anticheat disabled, in order to bypass ping spoof checks
                        // why the fuck do they not checked duped transactions? LMFAO
                        packetBuffer.add(packet)
                    }
                    event.cancelEvent()
                }
            }

            "vulcangeyser" -> {
                if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                    val b = ByteArrayOutputStream()
                    val outputStream = DataOutputStream(b)
                    outputStream.writeUTF(mc.thePlayer.gameProfile.name)
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("vulcan:geyser", buf))
                }
            }

            "oldkauri" -> {
                if (packet is C0FPacketConfirmTransaction)
                    event.cancelEvent()
            }

            "mmcstrafe" -> {
                if (packet is C0FPacketConfirmTransaction && mc.thePlayer.ticksExisted % 3 == 0)
                    event.cancelEvent()
            }

            "ridingspoof" -> {
                if (packet is C03PacketPlayer)
                    mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
            }

            "basic" -> {
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive)
                    event.cancelEvent()
            }

            "nogroundtouch2" -> {
                if (packet is C03PacketPlayer)
                    packet.y += 0.125
            }

            "spectate" -> {
                if (packet is C03PacketPlayer)
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
            }

            "spectatespoof" -> {
                if (packet is C03PacketPlayer) {
                    packet.onGround = false

                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                }
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }

            "spectatespoof2" -> {
                if (packet is C03PacketPlayer)
                    mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
                if (packet is C13PacketPlayerAbilities) {
                    packet.isFlying = true
                    packet.isInvulnerable = true
                    packet.isAllowFlying = true
                    packet.isCreativeMode = false
                }
            }


            "flying" -> {
                if (packet is C03PacketPlayer) {
                    val capabilities= PlayerCapabilities() // flags=2
                    capabilities.disableDamage=false
                    capabilities.isFlying=true
                    capabilities.allowFlying=false
                    capabilities.isCreativeMode=false
                    mc.netHandler.addToSendQueue(C13PacketPlayerAbilities(capabilities))
                    debugMessage("Packet C13")
                }
            }

            "memetrixscaffold" -> {
                if(packet is C03PacketPlayer&&!(packet is C03PacketPlayer.C04PacketPlayerPosition ||packet is C03PacketPlayer.C05PacketPlayerLook ||packet is C03PacketPlayer.C06PacketPlayerPosLook)){
                    event.cancelEvent()
                }
                if(packet is C02PacketUseEntity||packet is C03PacketPlayer.C04PacketPlayerPosition ||packet is C03PacketPlayer.C05PacketPlayerLook
                    ||packet is C03PacketPlayer.C06PacketPlayerPosLook ||packet is C07PacketPlayerDigging||packet is C08PacketPlayerBlockPlacement
                    ||packet is C0APacketAnimation||packet is C0BPacketEntityAction){
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }

            "fakelag" -> {
                if(fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                    if(isSent && fakeLagSpoofValue.get()) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        if(lagDurationValue.get()>=300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        isSent = false
                    }
                    if(packet is C00PacketKeepAlive||packet is C0FPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagAttackValue.get()&&(packet is C02PacketUseEntity||packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                        if(packet is C0APacketAnimation) return
                    }
                    if(fakeLagBlockValue.get()&&(packet is C07PacketPlayerDigging||packet is C08PacketPlayerBlockPlacement||packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if(fakeLagPosValue.get()&&(packet is C03PacketPlayer/*||packet is C03PacketPlayer.C04PacketPlayerPosition ||packet is C03PacketPlayer.C05PacketPlayerLook ||packet is C03PacketPlayer.C06PacketPlayerPosLook*/ ||packet is C0BPacketEntityAction)){
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }

            "pingspoof" -> {
                if (event.isCancelled) return
                if (!mc.netHandler.isDoneLoadingTerrain) return
                if (packet.javaClass.name.startsWith("net.minecraft.network.play.client.")) {
                    event.cancelEvent()
                    if (pingSpoofLostC03Rate.get() > 0.0f && packet is C03PacketPlayer) {
                        val randomFloat = Math.random()
                        if (randomFloat < pingSpoofLostC03Rate.get()) {
                            if (pingSpoofLostC03Mode equal "NoMove") {
                                if (!packet.isMoving && !packet.rotating && !mc.thePlayer.isUsingItem) return
                            } else {
                                if (!packet.isMoving && packet.rotating && !mc.thePlayer.isUsingItem) return
                            }
                        }
                    }
                    val event1 = PacketEvent(packet,PacketEvent.Type.SEND)
                    KevinClient.eventManager.callEvent(event1)
                    if (event1.isCancelled) return
                    val event12 = PacketEvent(packet,PacketEvent.Type.RECEIVE)
                    KevinClient.eventManager.callEvent(event12)
                    if (event12.isCancelled) return
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }

            "nogroundtouch" -> {
                PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX,
                    mc.thePlayer.posY + .125, mc.thePlayer.posZ, true))
            }

            "c13+infinitec0c" -> {
                PacketUtils.sendPacketNoEvent(C13PacketPlayerAbilities(mc.thePlayer.capabilities))
                PacketUtils.sendPacketNoEvent(C0CPacketInput(Float.MAX_VALUE, Float.MAX_VALUE, false, false))
            }
            "mineland" -> {
                if (packet is S08PacketPlayerPosLook) isSent = false
            }
            "lessflag" -> {
                if (packet is S08PacketPlayerPosLook) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        PacketUtils.sendPacketNoEvent(
                            C03PacketPlayer.C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.getYaw(),
                                packet.getPitch(),
                                true
                            )
                        )
                        debugMessage("Flag Reduced")
                    } else {
                        debugMessage("Too Far Away")
                    }
                }
            }
        }
        if (vulcanStrafeDisabler.get()) {
            if (packet is C03PacketPlayer) {
                ++vulcanStrafeC03Counter
                if (packet.isMoving) {
                    if (vulcanStrafeC03Counter >= vulcanStrafeDelay.get()) {
                        mc.netHandler.addToSendQueue(C07PacketPlayerDigging(C07PacketPlayerDigging.Action.STOP_DESTROY_BLOCK, BlockPos.ORIGIN, EnumFacing.DOWN))
                        vulcanStrafeC03Counter = 0
                    } else if (vulcanStrafeC03Counter == vulcanStrafeDelay.get() - 2) {
                        mc.netHandler.addToSendQueue(C07PacketPlayerDigging(C07PacketPlayerDigging.Action.START_DESTROY_BLOCK, BlockPos.ORIGIN, EnumFacing.DOWN))
                    }
                }
            }
        }

    }

    private fun resendPacket(packet: Packet<*>) {
        mc.netHandler.networkManager.sendPacketNoEvent(packet)
    }

    fun releaseAllPackets() {

    }

    private fun debugMessage(str: String){
        if(debug.get())
            ChatUtils.messageWithStart(" [Disabler] $str")
    }

    override val tag: String
        get() = modeValue.get()
}