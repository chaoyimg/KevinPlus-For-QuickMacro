/*
 * This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package kevin.module.modules.exploit

import kevin.event.*
import kevin.module.ListValue
import kevin.module.Module
import kevin.module.ModuleCategory
import kevin.utils.BlockUtils
import kevin.utils.MovementUtils
import kevin.utils.PacketUtils
import kevin.utils.TickTimer
import net.minecraft.block.BlockAir
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

class Phase : Module("Phase", "Allows you to walk through blocks.", category = ModuleCategory.EXPLOIT) {

    private val modeValue = ListValue("Mode", arrayOf("Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex", "Matrix"), "Vanilla")

    private val tickTimer = TickTimer()

    private var mineplexClip = false
    private val mineplexTickTimer = TickTimer()

    private var matrixClip = false
    private val matrixTickTimer = TickTimer()

    override fun onDisable() {
        mc.timer.timerSpeed = 1f
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {

        //if (event.eventState == UpdateState.OnUpdate) return

        val isInsideBlock: Boolean =
            BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { block ->
                (block)!is BlockAir
            }
        if (isInsideBlock && !modeValue.get().equals("Mineplex",true) && !(modeValue equal "Matrix")) {
            mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = false
        }
        whenMode(isInsideBlock)
        tickTimer.update()
    }

    private fun whenMode(isInsideBlock: Boolean) {
        val netHandlerPlayClient = mc.netHandler
        when (modeValue.get().lowercase()) {
            "vanilla" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.2, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.thePlayer.setPosition(
                    mc.thePlayer.posX + x,
                    mc.thePlayer.posY,
                    mc.thePlayer.posZ + z
                )
                tickTimer.reset()
            }
            "skip" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                val direction: Double = MovementUtils.direction
                val posX = -sin(direction) * 0.3
                val posZ = cos(direction) * 0.3
                var i = 0
                while (i < 3) {
                    mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.06, mc.thePlayer.posZ, true))
                    mc.netHandler.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + posX * i, mc.thePlayer.posY, mc.thePlayer.posZ + posZ * i, true))
                    ++i
                }
                mc.thePlayer.entityBoundingBox = mc.thePlayer.entityBoundingBox.offset(posX, .0, posZ)
                mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX + posX, mc.thePlayer.posY, mc.thePlayer.posZ + posZ)
                tickTimer.reset()
            }
            "spartan" -> {
                if (!mc.thePlayer.onGround || !tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 0.2, mc.thePlayer.posZ, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(0.5, .0, 0.5, true))
                netHandlerPlayClient.addToSendQueue(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX + 0.5, mc.thePlayer.posY, mc.thePlayer.posZ + 0.5, true))
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val x = -sin(yaw) * 0.04
                val z = cos(yaw) * 0.04
                mc.thePlayer.setPosition(mc.thePlayer.posX + x, mc.thePlayer.posY, mc.thePlayer.posZ + z)
                tickTimer.reset()
            }
            "clip" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX: Double = mc.thePlayer.posX
                val oldZ: Double = mc.thePlayer.posZ
                var i = 1
                while (i <= 10) {
                    val x = -sin(yaw) * i
                    val z = cos(yaw) * i
                    if ((BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY, oldZ + z))) is BlockAir
                        && (BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)))is BlockAir
                    ) {
                        mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                        break
                    }
                    i++
                }
                tickTimer.reset()
            }
            "aac3.5.0" -> {
                if (!tickTimer.hasTimePassed(2) || !mc.thePlayer
                        .isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking)
                ) return
                val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
                val oldX: Double = mc.thePlayer.posX
                val oldZ: Double = mc.thePlayer.posZ
                val x = -sin(yaw)
                val z = cos(yaw)
                mc.thePlayer.setPosition(oldX + x, mc.thePlayer.posY, oldZ + z)
                tickTimer.reset()
            }
        }
    }

    @EventTarget
    fun onBlockBB(event: BlockBBEvent) {
        if (mc.thePlayer != null && BlockUtils.collideBlockIntersects(
                mc.thePlayer.entityBoundingBox
            ) { block ->
                (block)!is BlockAir
            } && event.boundingBox != null && event.boundingBox!!.maxY > mc.thePlayer
                .entityBoundingBox.minY && !modeValue.get().equals("Mineplex",true) && !(modeValue equal "Matrix")
        ) {
            val axisAlignedBB = event.boundingBox ?: return
            event.boundingBox = (
                AxisAlignedBB(
                    axisAlignedBB.maxX,
                    mc.thePlayer.entityBoundingBox.minY,
                    axisAlignedBB.maxZ,
                    axisAlignedBB.minX,
                    axisAlignedBB.minY,
                    axisAlignedBB.minZ
                )
            )
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet
        if ((packet)is C03PacketPlayer) {
            if (modeValue.get().equals("AAC3.5.0",true)) {
                val yaw = MovementUtils.direction
                packet.x = (packet.x - sin(yaw) * 0.00000001)
                packet.z = (packet.z + cos(yaw) * 0.00000001)
            }
        }
        if (modeValue equal "Matrix") {
            if (packet is S08PacketPlayerPosLook) {
                val x = packet.x - mc.thePlayer.posX
                val y = packet.y - mc.thePlayer.posY
                val z = packet.z - mc.thePlayer.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    PacketUtils.sendPacketNoEvent(
                        C03PacketPlayer.C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.getYaw(),
                            packet.getPitch(),
                            true
                        )
                    )
                }
            }
        }
    }

    @EventTarget
    private fun onMove(event: MoveEvent) {
        if (modeValue.get().equals("mineplex",true)) {
            if (mc.thePlayer.isCollidedHorizontally) mineplexClip = true
            if (!mineplexClip) return
            mineplexTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (mineplexTickTimer.hasTimePassed(3)) {
                mineplexTickTimer.reset()
                mineplexClip = false
            } else if (mineplexTickTimer.hasTimePassed(1)) {
                val offset = if (mineplexTickTimer.hasTimePassed(2)) 1.6 else 0.06
                val direction: Double = MovementUtils.direction
                mc.thePlayer.setPosition(mc.thePlayer.posX + -sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + cos(direction) * offset)
            }
        }
        if (modeValue equal "Matrix") {
            if (mc.thePlayer.isCollidedHorizontally) {
                matrixClip = true
                mc.timer.timerSpeed = 0.05f
            }
            if (!matrixClip) return
            matrixTickTimer.update()
            event.x = 0.0
            event.z = 0.0
            if (matrixTickTimer.hasTimePassed(4)) {
                matrixTickTimer.reset()
                matrixClip = false
                mc.timer.timerSpeed = 1f
            } else if (matrixTickTimer.hasTimePassed(2)) {
                val offset = if (matrixTickTimer.hasTimePassed(3)) 1.6 else 0.06
                val direction: Double = MovementUtils.direction
                mc.thePlayer.setPosition(mc.thePlayer.posX + -sin(direction) * offset, mc.thePlayer.posY, mc.thePlayer.posZ + cos(direction) * offset)
            }
        }
    }

    @EventTarget fun onPushOut(event: PushOutEvent) = event.cancelEvent()

    override val tag: String
        get() = modeValue.get()
}