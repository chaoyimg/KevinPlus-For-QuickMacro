package kevin.module.modules.exploit

import kevin.event.EventTarget
import kevin.event.PacketEvent
import kevin.event.UpdateEvent
import kevin.event.WorldEvent
import kevin.main.KevinClient
import kevin.module.Module
import kevin.module.ModuleCategory
import kevin.utils.PacketUtils
import net.minecraft.client.gui.GuiDownloadTerrain
import net.minecraft.network.INetHandler
import net.minecraft.network.Packet
import net.minecraft.network.login.server.S00PacketDisconnect
import net.minecraft.network.login.server.S01PacketEncryptionRequest
import net.minecraft.network.login.server.S02PacketLoginSuccess
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.server.*
import net.minecraft.network.status.server.S00PacketServerInfo
import net.minecraft.network.status.server.S01PacketPong
import java.util.concurrent.ConcurrentLinkedDeque
import java.util.concurrent.CopyOnWriteArrayList

object CTPMender : Module("CTPMender", "Mend C0F", category = ModuleCategory.EXPLOIT) {
    private var lastResult = false
    private var storedPackets: CopyOnWriteArrayList<Packet<INetHandler>> = CopyOnWriteArrayList()
    var pingPackets = ConcurrentLinkedDeque<Int>()
    var canDelay: Boolean = false
    var transactions: Int = 0



    override fun onEnable() {
        transactions = 0
        canDelay = false
    }

    @EventTarget
    fun onWorld(event: WorldEvent){
        transactions = 0
        canDelay = false
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if (mc.thePlayer == null) return
        if (mc.thePlayer.isDead) return

        if (packet is S01PacketJoinGame) {
            canDelay = false
        }






    }
    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        if (!getGrimPost()) {
            processPackets()
        }
    }
    fun getGrimPost(): Boolean {
        val result = state  && mc.thePlayer != null && mc.thePlayer.isEntityAlive && mc.thePlayer.ticksExisted >= 20 && canDelay && mc.currentScreen !is GuiDownloadTerrain
        if (lastResult && !result) {
            lastResult = result
            mc.addScheduledTask { processPackets() }
        }
        lastResult = result
        return result
    }

    fun grimPostDelay(packet: Packet<*>?): Boolean {
        if (mc.thePlayer == null) return false
        if (mc.currentScreen is GuiDownloadTerrain) return false

        // connection packets
        if (packet is S00PacketServerInfo) return false
        if (packet is S01PacketEncryptionRequest) return false
        if (packet is S38PacketPlayerListItem) return false
        if (packet is S00PacketDisconnect) return false
        if (packet is S21PacketChunkData) return false
        if (packet is S01PacketPong) return false
        if (packet is S01PacketJoinGame) return false
        if (packet is S02PacketLoginSuccess) return false
        if (packet is S34PacketMaps) return false
        if (packet is S05PacketSpawnPosition) return false

        if (packet is S02PacketChat) return false
        if (packet is S45PacketTitle) return false

        // gameplay packets
        if (packet is S44PacketWorldBorder) return true
        if (packet is S01PacketJoinGame) return false
        if (packet is S19PacketEntityHeadLook) return false
        if (packet is S3EPacketTeams) return false
        if (packet is S02PacketChat) return false
        if (packet is S2FPacketSetSlot) return true
        if (packet is S1CPacketEntityMetadata) return true
        if (packet is S20PacketEntityProperties) return true
        if (packet is S35PacketUpdateTileEntity) return false
        if (packet is S03PacketTimeUpdate) return false
        if (packet is S47PacketPlayerListHeaderFooter) return false

        if (packet is S0BPacketAnimation) return false

        // velocity packets
        if (packet is S08PacketPlayerPosLook) return true
        if (packet is S12PacketEntityVelocity) return true
        if (packet is S27PacketExplosion) return true
        if (packet is S32PacketConfirmTransaction) return true
        if (packet is S0CPacketSpawnPlayer) return true
        if (packet is S18PacketEntityTeleport) return true
        if (packet is S19PacketEntityStatus) return true
        if (packet is S04PacketEntityEquipment) return true
        if (packet is S23PacketBlockChange) return true
        if (packet is S22PacketMultiBlockChange) return true
        if (packet is S13PacketDestroyEntities) return true
        if (packet is S00PacketKeepAlive) return true
        if (packet is S06PacketUpdateHealth) return true
        if (packet is S2EPacketCloseWindow) return true
        if (packet is S14PacketEntity) return true
        if (packet is S0FPacketSpawnMob) return true
        if (packet is S2DPacketOpenWindow) return true
        if (packet is S30PacketWindowItems) return true
        if (packet is S31PacketWindowProperty) return true
        if (packet is S3FPacketCustomPayload) return true
        if (packet is S1DPacketEntityEffect) return true
        if (packet is S28PacketEffect) return true
        if (packet is S25PacketBlockBreakAnim) return true
        if (packet is S0EPacketSpawnObject) return true
        if (packet is S0DPacketCollectItem) return true
        if (packet is S39PacketPlayerAbilities) return true
        if (packet is S2CPacketSpawnGlobalEntity) return true

        return false
    }
    fun processPackets() {
        if (!storedPackets.isEmpty()) {
            for (packet in storedPackets) {
                val event = PacketEvent(packet,PacketEvent.Type.RECEIVE)
                KevinClient.eventManager.callEvent(event)
                if (event.isCancelled) {
                    continue
                }

                try {
                    packet.processPacket(mc.netHandler)
                } catch (ignored: Exception) {
                    println(ignored.message)
                }
            }
            storedPackets.clear()
        }
    }

    fun addPacket(packet: Packet<*>?) {
        storedPackets.add(packet as Packet<INetHandler>?)
    }

    fun fixPost(packet: C0FPacketConfirmTransaction) {
        val id = packet.uid
        if (id >= 0 || pingPackets.isEmpty()) {
            PacketUtils.sendPacketNoEvent(packet)
        } else {
            while (true) {
                val current: Int = pingPackets.first
                PacketUtils.sendPacketNoEvent(C0FPacketConfirmTransaction(packet.windowId, current.toShort(), true))
                pingPackets.pollFirst()
                if (current == id.toInt() || pingPackets.isEmpty()) {
                    break
                }
            }
        }
    }

    override val tag: String
        get() = "Faust"
}
